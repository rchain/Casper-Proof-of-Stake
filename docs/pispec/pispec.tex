% ------------------------------------------------------------------------
% AMS-LaTeX Paper ********************************************************
% ------------------------------------------------------------------------
% Submitted:      Dec 15 2003
% Final Version:  
% Accepted:       
% ------------------------------------------------------------------------
% This is a journal top-matter template file for use with AMS-LaTeX.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO(mike): locating a closure at a name: how to translate a closure into a process that gets stuck into the cell



%\documentclass{tran-l}
%\documentclass[twocolumn]{amsart}
%\documentclass[]{amsart}
%\documentclass[]{sig-alternate}
%\documentclass[fleqn]{acm_proc_article-sp}
\documentclass[]{acm_proc_article-sp}
%\documentclass[]{llncs}


%\documentclass[]{prentcsmacro}

%\usepackage[active]{srcltx} % SRC Specials for DVI Searching
\usepackage{url}
% \usepackage[pdf]{pstricks}
% \usepackage{pstricks-add, pst-grad, pst-plot}
% \usepackage[tiling]{pst-fill}
% \psset{linewidth=0.3pt,dimen=middle}
% \psset{xunit=.70cm,yunit=0.70cm}
% \psset{angleA=-90,angleB=90,ArrowInside=->,arrowscale=2}


% From Allen's stable.
\usepackage{bigpage}
\usepackage{bcprules}
%\usepackage{code}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{mathtools}
%\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{cmll}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{caption}
%\usepackage{multicol}


% Math
\newcommand{\maps}{\colon}
\newcommand{\NN}{\mathbb{N}}
% Double brackets
\newcommand{\ldb}{[\![}
\newcommand{\rdb}{]\!]}
\newcommand{\ldrb}{(\!(}
\newcommand{\rdrb}{)\!)}
\newcommand{\lliftb}{\langle\!|}
\newcommand{\rliftb}{|\!\rangle}
% \newcommand{\lpquote}{\langle}
% \newcommand{\rpquote}{\rangle}
% \newcommand{\lpquote}{\lceil}
% \newcommand{\rpquote}{\rceil}
\newcommand{\lpquote}{\ulcorner}
\newcommand{\rpquote}{\urcorner}
\newcommand{\newkw}{\nu}

% SYNTAX
\newcommand{\id}[1]{\texttt{#1}}
\newcommand{\none}{\emptyset}
\newcommand{\eps}{\epsilon}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\rep}[2]{\id{\{$#1$,$#2$\}}}
\newcommand{\elt}[2]{\id{$#1$[$#2$]}}
\newcommand{\infinity}{$\infty$}

\newcommand{\pzero}{\mathbin{0}}
\newcommand{\seq}{\mathbin{\id{,}}}
\newcommand{\all}{\mathbin{\id{\&}}}
\newcommand{\choice}{\mathbin{\id{|}}}
\newcommand{\altern}{\mathbin{\id{+}}}
\newcommand{\juxtap}{\mathbin{\id{|}}}
%\newcommand{\concat}{\mathbin{.}}
\newcommand{\concat}{\Rightarrow}
\newcommand{\punify}{\mathbin{\id{:=:}}}
\newcommand{\fuse}{\mathbin{\id{=}}}
\newcommand{\scong}{\mathbin{\equiv}}
\newcommand{\nameeq}{\mathbin{\equiv_N}}
\newcommand{\alphaeq}{\mathbin{\equiv_{\alpha}}}
\newcommand{\names}[1]{\mathbin{\mathcal{N}(#1)}}
\newcommand{\freenames}[1]{\mathbin{\mathcal{FN}(#1)}}
\newcommand{\boundnames}[1]{\mathbin{\mathcal{BN}(#1)}}
%\newcommand{\lift}[2]{\texttt{lift} \; #1 \concat #2}
\newcommand{\binpar}[2]{#1 \juxtap #2}
\newcommand{\outputp}[2]{#1 ! ( * #2 )}
\newcommand{\prefix}[3]{#1 ? ( #2 ) \concat #3}
\newcommand{\lift}[2]{#1 ! ( #2 )}
%\newcommand{\quotep}[1]{\lpquote #1 \rpquote}
\newcommand{\quotep}[1]{@#1}
\newcommand{\dropn}[1]{*#1}

\newcommand{\newp}[2]{\id{(}\newkw \; #1 \id{)} #2}
\newcommand{\bangp}[1]{\int #1}
\newcommand{\xbangp}[2]{\int_{#2} #1}
\newcommand{\bangxp}[2]{\int^{#2} #1}

\newcommand{\substp}[2]{\id{\{} \quotep{#1} / \quotep{#2} \id{\}}}
\newcommand{\substn}[2]{\id{\{} #1 / #2 \id{\}}}

\newcommand{\psubstp}[2]{\widehat{\substp{#1}{#2}}}
\newcommand{\psubstn}[2]{\widehat{\substn{#1}{#2}}}

\newcommand{\applyp}[2]{#1 \langle #2 \rangle}
\newcommand{\absp}[2]{\id{(} #1 \id{)} #2}

\newcommand{\transitions}[3]{\mathbin{#1 \stackrel{#2}{\longrightarrow} #3}}
\newcommand{\meaningof}[1]{\ldb #1 \rdb}
\newcommand{\pmeaningof}[1]{\ldb #1 \rdb}
\newcommand{\nmeaningof}[1]{\ldrb #1 \rdrb}

\newcommand{\Proc}{\mathbin{Proc}}
\newcommand{\QProc}{\quotep{\mathbin{Proc}}}

\newcommand{\entailm}{\mathbin{\vdash_{\mathfrak m}}} %matching
\newcommand{\entailp}{\mathbin{\vdash_{\mathfrak p}}} %behavioral
\newcommand{\entailv}{\mathbin{\vdash_{\mathfrak v}}} %validation
\newcommand{\congd}{\mathbin{\equiv_{\mathfrak d}}}
\newcommand{\congs}{\mathbin{\equiv_{\mathfrak s}}}
\newcommand{\congp}{\mathbin{\equiv_{\mathfrak p}}}
%\newcommand{\defneqls}{:\!=}
\newcommand{\defneqls}{\coloneqq}
%\newcommand{\logequiv}{\mathbin{\leftrightarrow}}

\newcommand{\barb}[2]{\mathbin{#1 \downarrow_{#2}}}
\newcommand{\dbarb}[2]{\mathbin{#1 \Downarrow_{#2}}}

% From pi-duce paper
\newcommand{\red}{\rightarrow}
\newcommand{\wred}{\Rightarrow}
\newcommand{\redhat}{\hat{\longrightarrow}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}} %transitions
\newcommand{\wlred}[1]{\stackrel{#1}{\Longrightarrow}}

\newcommand{\opm}[2]{\overline{#1} [ #2 ]} % monadic
\newcommand{\ipm}[2]{{#1} ( #2 )} 
\newcommand{\ipmv}[2]{{#1} ( #2 )} % monadic
\newcommand{\parop}{\;|\;}    % parallel operator
\newcommand{\patmatch}[3]{#2 \in #3 \Rightarrow #1}
\newcommand{\sdot}{\, . \,}    % Space around '.'
\newcommand{\bang}{!\,}
%\newcommand{\fuse}[1]{\langle #1 \rangle}    
\newcommand{\fusion}[2]{#1 = #2} % fusion prefix/action
\newcommand{\rec}[2]{\mbox{\textsf{rec}} \, #1. \, #2}
\newcommand{\match}[2]{\mbox{\textsf{match}} \; #1 \; \mbox{\textsf{with}} \; #2}
\newcommand{\sep}{:}
\newcommand{\val}[2]{\mbox{\textsf{val}} \; #1 \; \mbox{\textsf{as}} \; #2}

\newcommand{\rel}[1]{\;{\mathcal #1}\;} %relation
\newcommand{\bisim}{\stackrel{.}{\sim}_b} %bisimilar
\newcommand{\wb}{\approx_b} %weak bisimilar
\newcommand{\bbisim}{\stackrel{\centerdot}{\sim}} %barbed bisimilar
\newcommand{\wbbisim}{\stackrel{\centerdot}{\approx}} %weak barbed bisimilar
\newcommand{\wbbisimsem}{\approx} %weak barbed bisimilar
\newcommand{\bxless}{\lesssim}  %expansion less (amssymb required)
\newcommand{\bxgtr}{\gtrsim}  %expansion greater (amssymb required)
\newcommand{\beq}{\sim}    %barbed congruent
\newcommand{\fwbeq}{\stackrel{\circ}{\approx}}  %weak barbed congruent
\newcommand{\wbeq}{\approx}  %weak barbed congruent
\newcommand{\sheq}{\simeq}  %symbolic hypereq
\newcommand{\wbc}{\approx_{cb}}

% End piduce contribution

% rho logic

\newcommand{\ptrue}{\mathbin{true}}
\newcommand{\psatisfies}[2]{#1 \models #2}
\newcommand{\pdropf}[1]{\rpquote #1 \lpquote}
\newcommand{\pquotep}[1]{\lpquote #1 \rpquote}
\newcommand{\plift}[2]{#1 ! ( #2 )}
\newcommand{\pprefix}[3]{\langle #1 ? #2 \rangle #3}
\newcommand{\pgfp}[2]{\textsf{rec} \; #1 \mathbin{.} #2}
\newcommand{\pquant}[3]{\forall #1 \mathbin{:} #2 \mathbin{.} #3}
\newcommand{\pquantuntyped}[2]{\forall #1 \mathbin{.} #2}
\newcommand{\riff}{\Leftrightarrow}

\newcommand{\PFormula}{\mathbin{PForm}}
\newcommand{\QFormula}{\mathbin{QForm}}
\newcommand{\PropVar}{\mathbin{\mathcal{V}}}

\newcommand{\typedby}{\mathbin{\:\colon}}
\newcommand{\mixedgroup}[1]{\id{mixed($#1$)}}
\newcommand{\cast}[2]{\id{CAST AS} \; #1 \; (#2)}
\newcommand{\bslsh}{\mathbin{\id{\\}}}
\newcommand{\bslshslsh}{\mathbin{\id{\\\\}}}
\newcommand{\fslsh}{\mathbin{\id{/}}}
\newcommand{\fslshslsh}{\mathbin{\id{//}}}
\newcommand{\bb}[1]{\mbox{#1}}
\newcommand{\bc}{\mathbin{\mathbf{::=}}}
\newcommand{\bm}{\mathbin{\mathbf\mid}}
\newcommand{\be}{\mathbin{=}}
\newcommand{\bd}{\mathbin{\buildrel {\rm \scriptscriptstyle def} \over \be}}
\newcommand{\ctcategory}[1]{\mbox{\bf #1}}

%GRAMMAR
\newlength{\ltext}
\newlength{\lmath}
\newlength{\cmath}
\newlength{\rmath}
\newlength{\rtext}

\settowidth{\ltext}{complex type name}
\settowidth{\lmath}{$xxx$}
\settowidth{\cmath}{$::=$}
\settowidth{\rmath}{\id{attributeGroup}}
\settowidth{\rtext}{repetition of $g$ between $m$ and $n$ times}

\newenvironment{grammar}{
  \[
  \begin{array}{l@{\quad}rcl@{\quad}l}
  \hspace{\ltext} & \hspace{\lmath} & \hspace{\cmath} & \hspace{\rmath} & \hspace{\rtext} \\
}{
  \end{array}\]
}

% Over-full v-boxes on even pages are due to the \v{c} in author's name
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small

% THEOREM Environments ---------------------------------------------------
 \newtheorem{thm}{Theorem}[subsection]
 \newtheorem{cor}[thm]{Corollary}
 \newtheorem{lem}[thm]{Lemma}
 \newtheorem{prop}[thm]{Proposition}
% \theoremstyle{definition}
 \newtheorem{defn}[thm]{Definition}
% \theoremstyle{remark}
 \newtheorem{rem}[thm]{Remark}
 \newtheorem{example}[thm]{Example}
 \numberwithin{equation}{subsection}
% MATH -------------------------------------------------------------------
 \DeclareMathOperator{\RE}{Re}
 \DeclareMathOperator{\IM}{Im}
 \DeclareMathOperator{\ess}{ess}
 \newcommand{\veps}{\varepsilon}
 \newcommand{\To}{\longrightarrow}
 \newcommand{\h}{\mathcal{H}}
 \newcommand{\s}{\mathcal{S}}
 \newcommand{\A}{\mathcal{A}}
 \newcommand{\J}{\mathcal{J}}
 \newcommand{\M}{\mathcal{M}}
 \newcommand{\W}{\mathcal{W}}
 \newcommand{\X}{\mathcal{X}}
 \newcommand{\BOP}{\mathbf{B}}
 \newcommand{\BH}{\mathbf{B}(\mathcal{H})}
 \newcommand{\KH}{\mathcal{K}(\mathcal{H})}
 \newcommand{\Real}{\mathbb{R}}
 \newcommand{\Complex}{\mathbb{C}}
 \newcommand{\Field}{\mathbb{F}}
 \newcommand{\RPlus}{\Real^{+}}
 \newcommand{\Polar}{\mathcal{P}_{\s}}
 \newcommand{\Poly}{\mathcal{P}(E)}
 \newcommand{\EssD}{\mathcal{D}}
 \newcommand{\Lom}{\mathcal{L}}
 \newcommand{\States}{\mathcal{T}}
 \newcommand{\abs}[1]{\left\vert#1\right\vert}
% \newcommand{\set}[1]{\left\{#1\right\}}
%\newcommand{\seq}[1]{\left<#1\right>}
 \newcommand{\norm}[1]{\left\Vert#1\right\Vert}
 \newcommand{\essnorm}[1]{\norm{#1}_{\ess}}

%%% NAMES
\newcommand{\Names}{{\mathcal N}}
\newcommand{\Channels}{{\sf X}}
\newcommand{\Variables}{{\mathcal V}}
\newcommand{\Enames}{{\mathcal E}}
\newcommand{\Nonterminals}{{\mathcal S}}
\newcommand{\Pnames}{{\mathcal P}}
\newcommand{\Dnames}{{\mathcal D}}
\newcommand{\Types}{{\mathcal T}}

\newcommand{\fcalc}{fusion calculus}
\newcommand{\xcalc}{${\mathfrak x}$-calculus}
\newcommand{\lcalc}{$\lambda$-calculus}
\newcommand{\pic}{$\pi$-calculus}
\newcommand{\rhoc}{${\textsc{rho}}$-calculus}
\newcommand{\hcalc}{highwire calculus}
\newcommand{\dcalc}{data calculus}
%XML should be all caps, not small caps. --cb
%\newcommand{\xml}{\textsc{xml}}
\newcommand{\xml}{XML} 

\newcommand{\papertitle}{Formally introducing Casper}
% use static date to preserve date of actual publication
 \newcommand{\paperversion}{Draft Version 0.1 - Jul 30, 2015}

\newenvironment{toc}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
   \setlength{\parskip}{0pt}
 } \item }
{\end{list}}

\newenvironment{narrow}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
 } \item }
{\end{list}}

%%% ----------------------------------------------------------------------

%\title{\huge{\papertitle}}
\title{\papertitle}

%\numberofauthors{3}
\author{
Vlad Zamfir\\
  \affaddr{Ethereum}\\
  \email{\fontsize{8}{8}\selectfont vldzmfr@gmail.com}
\and
L.G. Meredith\\
  \affaddr{CSO, Synereo}\\
  \email{\fontsize{8}{8}\selectfont greg@synereo.com}
}

%\address{Systems Biology, Harvard Medical School, Boston, Massachussetts, USA}

%\email{lg_meredith@hms.harvard.edu}

%\thanks{This work was completed during a visiting appointment at the Department of Systems Biology, Harvard Medical School.}

%\subjclass{Primary 47A15; Secondary 46A32, 47D20}

%\date{April 6, 2002.}

%\dedicatory{}

%\commby{Daniel J. Rudolph}

%%% ----------------------------------------------------------------------

\begin{document}
%\lstset{language=erlang}
\lstset{language=}

%These margin values appear to be relative to the bigpage package settings. --cb
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}
\setlength{\parskip}{6pt}

\keywords{ {\pic}, proof-of-stake, blockchain, types, Curry-Howard }

\begin{abstract}
\normalsize{ 

  We present Casper, a proof-of-stake protocol, and it's formal specification in {\pic}.

}

\end{abstract}

% \noindent
% {\large \textbf{Submission to arXiv}}\\
% \rule{6.25in}{0.75pt}\\\\\\

%%% ----------------------------------------------------------------------
\maketitle
%%% ----------------------------------------------------------------------

% \begin{center}
% \paperversion\\
% \end{center}

% \begin{toc}
% \tableofcontents
% \end{toc}

% \newpage
% ------------------------------------------------------------------------

\section{Introduction and Motivation}

Consensus protocols build reliable processes out of unreliable
processes e.g. a process (or protocol) that provides a service by
replicating changes to a deterministic automata across many
potentially unreliable or untrusted computers

Consensus is… 

CAP Theorem In the event of a network partition, a consensus protocol
must choose between being available and being consistent

CAP Theorem Consistency: every correct server has an identical copy of
the state

Availability: clients are able affect changes to the server’s consensus state

Classes of Consensus Protocols Traditional consensus protocols tend to
prefer consistency over availability in the event of a partition

Blockchain-based consensus protocols can prefer availability over
consistency in the event of a partition

Exceptions that prove the rule Traditional consensus protocols that
are available in the event of a partition tend to use a protocol
extension to discover the validators in their partition, and then to
proceed ‘normally’ with this subset of validators

On Chaining Blocks The only consensus-critical reason to chain blocks
together is to restrict the number of possible futures/histories that
clients must compare when they are coming to consensus

This is only necessary in consensus protocols that favour availability

On Chaining Blocks We will return to blockchain-based consensus
protocols after reviewing traditional consensus protocols and economic
consensus protocols.

\subsubsection{Related work}

\subsubsection{Organization of the rest of the paper}

\section{Organizing some consensus on consensus}

Traditional Consensus Protocols
aim to have the following property:
Correct nodes make a change to the consensus state if and only if they are certain that in a finite amount of time all other correct nodes will make the same change

Traditional Consensus Protocols
They prove this property using the assumption that there exists no more than f (byzantine) faulty nodes, and that the remaining nodes are correct


Traditional Consensus Protocols
If a correct node sees something X that causes it to change its state, it knows that all undecided correct nodes will also process that change, when they see X

Traditional Consensus Protocols
If f nodes are faulty, 

f + 1 node signatures are required for a node to believe that the message was signed by at least one correct node

Traditional Consensus Protocols
…. For consensus we must know that a majority of correct nodes approve of a change to the state 
 f 

Traditional Consensus Protocols
Definition:

A “byzantine quorum” is a set of nodes large enough such that a majority of correct nodes must be contained in that set.
 f 

Traditional Consensus Protocols
faulty nodes
correct nodes
majority of correct nodes
byzantine quorum
0\%
100\%
>50\%
>50\%
33\%
67\%
>33.5\%
>66.5\%
50\%
50\%
>25\%
>75\%
80\%
20\%
>10\%
>90\%
 f 

Traditional Consensus Protocols
…. The size of the byzantine quorum is 

> (100\% - f)/2 + f
= 50\% + f/2

…. where f is the proportion of byzantine faults
 f 

Traditional Consensus Protocols
…. Unfortunately, faulty nodes can prevent a byzantine quorum from forming ….
 f 

Traditional Consensus Protocols
faulty nodes
correct nodes
majority of correct nodes
byzantine quorum (c1 + c3)
quorum surplus
(c2 - c4)
0\%
100\%
>50\%
>50\%
<50\%
33\%
67\%
>33.5\%
>66.5\%
<0.5\%
50\%
50\%
>25\%
>75\%
<-25\%
80\%
20\%
>10\%
>90\%
<-70\%
 f 

Traditional Consensus Protocols
A fault tolerance f > ⅓ would require a quorum size that is greater than ⅔.  This quorum cannot be guaranteed to form if there are more than 1 - ⅔ = ⅓ faults, 

….and we just assumed that f > ⅓.
 f 

Traditional Consensus Protocols
The highest fault tolerance we can hope for is:  
      f = ⅓ 

|quorum| = 50\% + (f + e)/2 = ⅔ + e/2
|correct| = 100\% - (f + e) = ⅔ - e |correct| < |quorum| by 3e/2, and we can only tolerate faults if |correct| >= |quorum|
 f 

Traditional Consensus Protocols
A correct node that sees evidence of the acceptance of a change from a byzantine quorum knows that a majority of correct nodes have accepted that change

Traditional Consensus Protocols
In this case it is possible for the correct node to safely commit the change to its state.



Traditional Consensus Protocols
We need to assume that:  A correct node “knows” that other correct nodes will commit to the same change to the consensus because it knows that they are using the same logic to update their copy of the state

Economic Consensus Protocols
In economic consensus, we relax the previous assumption. 

The network’s behaviour is constrained by the economics of the protocol rather than by the correctness of all-but-f nodes.

Economic Consensus Protocols..
Definition:
 Economic consensus protocols are consensus protocols that use economic mechanisms defined by the protocol to prevent byzantine faults.

Economic Consensus Protocols..
The security of an economic consensus protocol should be demonstrated through economic analysis.  Economic analysis is unfortunately much harder to conduct than byzantine fault tolerance analysis.


Economic Consensus Protocols..
In general we will aim to show that an economic consensus protocol is:  Incentive compatible: 
All nodes have a direct incentive to work together to update and secure the consensus against faults




Economic Consensus Protocols..
The most common type of incentive incompatibility is a majority coalition’s incentive to censor the remaining minority to increase their profitability.

In the worst case, a majority coalition has an incentive to reverse history.




Economic Consensus Protocols..
In general we will aim to also show that an economic consensus protocol is:  Robust against incentive attacks: 
It would require a large expenditure out of a large budget to break the protocol’s incentive compatibility.



Economic Consensus Protocols..
The most general incentive attack is called the bribe attack. 

In this attack model, the attacker can directly bribe any node to deviate from its current behaviour. We assume that all (or almost all) nodes will deviate if it is profitable.



Economic Consensus Protocols..
Common assumption: 

Economic consensus protocols enforce these fault-preventing incentive mechanisms only by specifying the behaviour of a ledger of digital assets defined in the consensus state

Economic Consensus Protocols..
This common assumption, together with the also common confusion of blockchain-based consensus protocols with economic consensus protocols is why people commonly refer to blockchains as “distributed ledgers”

Economic Consensus Protocols..
Example: 

Tendermint makes faults expensive by revoking the security deposits of faulty validators. 
These deposits must be placed by a validator for their blocks to represent valid changes to the consensus state.

Economic Consensus Protocols..
Counter-example: 

Transactions-as-PoW is a consensus protocol that is expensive to attack, but which does not use an internal ledger to achieve its economics. It requires transactions to be computationally expensive and to refer to previous transactions.

Blockchain-based consensus protocols
Achieve consensus by having nodes choose between competing histories (called blockchains or forks) based on a common fork-choice rule.

This is as opposed to achieving consensus exclusively by coordinating to extend history.

Blockchain-based consensus protocols
The ability to choose one version of events after having adopted another is the defining characteristic of blockchains.

Chaining blocks reduces the number of possible version of histories.

Blockchain-based consensus protocols
This property makes it possible for blockchains to favour availability over consistency in the event of a network partition. 

Blockchain-based consesnsus:  		CA(P)
Traditional consensus:                	CA(P)

Blockchain-based consensus protocols
have a kind of fault-tolerance that doesn’t exist in the context of traditional protocols:  The fork-based fault-tolerance is the proportion of network resources required to create a fork that is chosen by the fork-choice rule in favour of any fork that can be created by the remaining nodes.

Blockchain-based consensus protocols
Traditionally, blockchain-based consensus protocols have a fork-based fault-tolerance of 50\%.

Traditional fault tolerance refers to the number of nodes that can be byzantine while it is still impossible for correct nodes to disagree.

Blockchain-based consensus protocols
Traditional fault tolerance: “How many of the nodes who made this fork would need to be byzantine for it to possibly be reverted?”  Fork-based fault tolerance: “How many nodes need to be byzantine for the guarantee that the winning fork is one created by correct nodes?”

Decentralization analysis
Traditional: “How many nodes need to be byzantine for there to be a commitment that matches this one?”  Fork-based: “How many nodes need to be correct, to guarantee that the winning fork is the one created by correct nodes?”

Economic Consensus Protocols..
Example: 

Bitcoin makes faults expensive by making blocks computationally expensive to produce, while rewarding miners through the issuance of new bitcoin only for producing blocks on the “heaviest chain”.


Economic Consensus Protocols..
Example, continued: 

Miners who don’t produce blocks at the head of the heaviest chain have to incur the computational expense but are not compensated for it… unless the blocks later become part of the heaviest chain.


Economic Consensus Protocols..
Example, continued: 

By conducting a “51\% attack”, Bitcoin miners can work in a majority coalition to make a “lighter” fork into the “heaviest” fork. 



Economic Consensus Protocols..
Example, continued: 

We therefore commonly say that Bitcoin has a byzantine fault tolerance of 50\%.
 Economic analysis, on the other hand, is not that simple..


Economic Consensus Protocols..
Example, continued: If we want to show that the Bitcoin protocol is secured by economics rather than by correct nodes, we must show that it is incentive compatible and robust to incentive attacks, ideally with as few assumptions as possible.


Economic Consensus Protocols..

Hence the term “distributed ledger”, which is unfortunately 

\section{Casper, informally}

\section{The calculus}

One notable feature of the {\pic} is its ability to succinctly and
faithfully model a number of phenomena of concurrent and distributed
computing. Competition for resources amongst autonomously executing
processes is a case in point. The expression
\begin{equation*}
  x?( y ) \Rightarrow P \juxtap x!( u ) \juxtap x?( v ) \Rightarrow Q
\end{equation*}
is made by composing three processes, two of which, $x?( y )
\Rightarrow P$ and $x?( v ) \Rightarrow Q$ are seeking input from
channel $x$ before they launch their respective continuations, $P$
and/or $Q$; while the third, $x!( u )$, is supplying output on that
same said channel. Only one of the input-guarded processes will win,
receiving $u$ and binding it to the input variable, $y$, or
respectively, $v$ in the body of the corresponding continuation --
while the loser remains in the input-guarded state awaiting input
along channel $x$. The calculus is equinanimous, treating both
outcomes as equally likely, and in this regard is unlike its
sequential counterpart, the $\lambda$-calculus, in that it is not
\emph{confluent}. There is no guarantee that the different branches of
computation must eventually converge. Note that just adding a
$\mathsf{new}$-scope around the expression
\begin{equation*}
  (\mathsf{new}\; x)( x?( y ) \Rightarrow P \juxtap x!( u ) \juxtap x?( v ) \Rightarrow Q )
\end{equation*}
ensures that the competition is for a local resource, hidden from any
external observer.

\subsection{Our running process calculus}

\subsubsection{Syntax}
\label{syntax}
\begin{grammar}
{P} \bc \pzero & \mbox{stopped process} \\
       \;\;\; \bm \; {x}{?}{( y_1, \ldots, y_n )} \Rightarrow {P} & \mbox{input} \\
       \;\;\; \bm \; {x}{!}{( y_1, \ldots, y_n )} & \mbox{output} \\
%       \;\;\; \bm \; {M}{+}{N} & \mbox{choice} \\
%{ P, Q } \bc M & \mbox{include IO processes} \\                                
       \;\;\; \bm \; (\mathsf{new}\; x){P} & \mbox{new channel} \\
       \;\;\; \bm \; {P} \juxtap {Q} & \mbox{parallel} \\                                
\end{grammar}

Due to space limitations we do not treat replication, $!P$.

\subsubsection{Free and bound names}

\begin{equation*}
  \begin{aligned}
    & \freenames{\pzero} \defneqls \emptyset \\
    & \freenames{{x}{?}{( y_1, \ldots, y_n )} \Rightarrow {P}} \defneqls \\
    & \;\;\;\;\;\{ x \} \cup (\freenames{P} \setminus \{ y_1, \ldots y_n \}) \\
    & \freenames{{x}{!}{( y_1, \ldots, y_n )}} \defneqls \{ x, y_1, \ldots, y_n \} \\
    & \freenames{(\mathsf{new}\; x){P}} \defneqls \freenames{P} \setminus \{x\} \\    
    & \freenames{{P} \juxtap {Q}} \defneqls \freenames{P} \cup \freenames{Q} \\
  \end{aligned}
\end{equation*}

An occurrence of $x$ in a process $P$ is \textit{bound} if it is not
free. The set of names occurring in a process (bound or free) is
denoted by $\names{P}$.

\subsubsection{Structural congruence}
\label{congruence}

The {\em structural congruence} of processes, noted $\scong$, is the
least congruence containing $\alpha$-equivalence, $\alphaeq$, making
$( P, |, 0 )$ into commutative monoids and satisfying

\begin{equation*}  
  (\mathsf{new}\; x)(\mathsf{new}\; x){P} \scong (\mathsf{new}\; x)P
\end{equation*}
\begin{equation*}  
  (\mathsf{new}\; x)(\mathsf{new}\; y){P} \scong (\mathsf{new}\; y)(\mathsf{new}\; x)P
\end{equation*}
\begin{equation*}  
  ((\mathsf{new}\; x){P}) \juxtap {Q} \scong (\mathsf{new}\; x)({P} \juxtap {Q})
\end{equation*}

\subsubsection{Operational Semantics}\label{section:opsem}
 
\infrule[Comm]
{ |\vec{y}| = |\vec{z}| }
%{P_1 + {{ x_{0}{?}{(}{\vec{y}}{)} \concat {P}}\juxtap {x_{1}}{!}{(}{\vec{z}}{)} + P_2}
{{{ x{?}{(}{\vec{y}}{)} \concat {P}}\juxtap {x}{!}{(}{\vec{z}}{)}}
\red {{P}{\{}\vec{z}{/}{\vec{y}}{\}}}}

In addition, we have the following context rules:

\infrule[Par]{{P} \red {P}'}{{{P} \juxtap {Q}} \red {{P}' \juxtap {Q}}}

\infrule[New]{{P} \red {P}'}{{(\mathsf{new}\; x){P}} \red {(\mathsf{new}\; x){P}'}}

\infrule[Equiv]{{{P} \scong {P}'} \andalso {{P}' \red {Q}'} \andalso {{Q}' \scong {Q}}}{{P} \red {Q}}

\subsubsection{Bisimulation}

\begin{defn}
An \emph{observation relation}, $\downarrow$ is the smallest relation satisfying the rules
below.

\infrule[Out-barb]{ }
      {{x}!(\vec{y}) \downarrow x}
\infrule[Par-barb]{\mbox{$P\downarrow x$ or $Q\downarrow x$}}
      {{P} \juxtap {Q} \downarrow x}

% We write $P \Downarrow x$ if there is $Q$ such that 
% $P \wred Q$ and $Q \downarrow x$.
\end{defn}

Notice that $\prefix{x}{y}{P}$ has no barb.  Indeed, in {\pic} as well
as other asynchronous calculi, an observer has no direct means to
detect if a sent message has been received or not.

\begin{defn}
%\label{def.bbisim}
An \emph{barbed bisimulation}, is a symmetric binary relation 
${\mathcal S}$ between agents such that $P\rel{S}Q$ implies:
\begin{enumerate}
\item If $P \red P'$ then $Q \red Q'$ and $P'\rel{S} Q'$.
\item If $P\downarrow x$, then $Q\downarrow x$.
\end{enumerate}
$P$ is barbed bisimilar to $Q$, written
$P \wbbisim Q$, if $P \rel{S} Q$ for some barbed bisimulation ${\mathcal S}$.
\end{defn}

\section{Formally introducing Casper}

\paragraph{Acknowledgments}
We would like to acknowledge Anthony D'Onofrio for putting us in touch.

% ------------------------------------------------------------------------
%GATHER{Xbib.bib}   % For Gather Purpose Only
%GATHER{Paper.bbl}  % For Gather Purpose Only
\bibliographystyle{amsplain}
\bibliography{pispec}

% ------------------------------------------------------------------------

\section{Appendix: because every technical paper needs an appendix}



% ------------------------------------------------------------------------

\end{document}
% ------------------------------------------------------------------------
